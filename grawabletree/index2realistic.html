<!DOCTYPE html>
<html lang="tr">
  <head>
    <meta charset="utf-8" />
    <title>Growable 3D Tree – Three.js</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      html,
      body {
        margin: 0;
        height: 100%;
        background: #0c1117;
        color: #e6edf3;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu,
          Cantarell, Noto Sans, sans-serif;
      }
      #ui {
        position: fixed;
        top: 12px;
        left: 12px;
        padding: 10px 12px;
        background: rgba(20, 25, 33, 0.7);
        border: 1px solid #2d3642;
        border-radius: 10px;
        backdrop-filter: blur(6px);
        font-size: 12px;
        line-height: 1.4;
        z-index: 10;
      }
      #ui label {
        display: block;
        margin: 6px 0 2px;
        opacity: 0.9;
      }
      #ui input[type="range"] {
        width: 220px;
      }
      #ui button {
        margin-top: 8px;
        padding: 6px 10px;
        border-radius: 8px;
        border: 1px solid #2d3642;
        background: #1a2332;
        color: #e6edf3;
        cursor: pointer;
      }
      #ui button:hover {
        background: #223048;
      }
    </style>
  </head>
  <body>
    <div id="ui">
      <div><strong>Growable 3D Tree</strong></div>
      <label>Iteration (1–7): <span id="itv">5</span></label>
      <input id="iter" type="range" min="1" max="7" value="5" />
      <label>Branch Angle (deg): <span id="angv">26</span></label>
      <input id="angle" type="range" min="10" max="50" value="26" />
      <label>Randomness: <span id="rndv">0.25</span></label>
      <input id="rand" type="range" min="0" max="1" step="0.01" value="0.25" />
      <label>Grow Time (s): <span id="grwv">6.0</span></label>
      <input id="grow" type="range" min="1" max="12" step="0.1" value="6.0" />

      <div style="margin-top: 6px">
        <button id="regen">Ağacı Yeniden Üret</button>
        <button id="replay">Animasyonu Yeniden Oynat</button>
      </div>
    </div>

    <!-- DİKKAT: sadece bu iki script, başka JS yok -->
    <script src="https://unpkg.com/three@0.146.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.146.0/examples/js/controls/OrbitControls.js"></script>

    <script>
      // --------------------------------------------------------
      // THREE SETUP
      // --------------------------------------------------------
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.outputEncoding = THREE.sRGBEncoding;
      document.body.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.background = new THREE.Color("#0b1015");
      scene.fog = new THREE.Fog(scene.background.getHex(), 10, 40);

      const camera = new THREE.PerspectiveCamera(
        55,
        window.innerWidth / window.innerHeight,
        0.1,
        200
      );
      camera.position.set(10, 7, 14);

      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 3, 0);
      controls.enableDamping = true;

      // ışıklar: güneş + gökyüzü + zemin yansıması
      scene.add(new THREE.AmbientLight(0xffffff, 0.25));

      const hemi = new THREE.HemisphereLight(0xb6d4ff, 0x182018, 0.7);
      scene.add(hemi);

      const sun = new THREE.DirectionalLight(0xfff2d2, 1.2);
      sun.position.set(15, 20, 8);
      scene.add(sun);

      // zemin
      const groundGeom = new THREE.CircleGeometry(30, 72);
      groundGeom.rotateX(-Math.PI / 2);
      const groundMat = new THREE.MeshStandardMaterial({
        color: 0x18241d,
        roughness: 0.95,
        metalness: 0,
      });
      const ground = new THREE.Mesh(groundGeom, groundMat);
      scene.add(ground);

      // hafif “çim” efekti için küçük gürültü
      const grassGeom = new THREE.CircleGeometry(7, 48);
      grassGeom.rotateX(-Math.PI / 2);
      const grassMat = new THREE.MeshStandardMaterial({
        color: 0x1c3b25,
        roughness: 0.9,
        metalness: 0,
      });
      const grass = new THREE.Mesh(grassGeom, grassMat);
      grass.position.y = 0.01;
      scene.add(grass);

      // --------------------------------------------------------
      // UI
      // --------------------------------------------------------
      const iterInput = document.getElementById("iter");
      const angleInput = document.getElementById("angle");
      const randInput = document.getElementById("rand");
      const growInput = document.getElementById("grow");

      const itv = document.getElementById("itv");
      const angv = document.getElementById("angv");
      const rndv = document.getElementById("rndv");
      const grwv = document.getElementById("grwv");

      [iterInput, angleInput, randInput, growInput].forEach((inp) => {
        inp.addEventListener("input", () => {
          itv.textContent = iterInput.value;
          angv.textContent = angleInput.value;
          rndv.textContent = randInput.value;
          grwv.textContent = growInput.value;
        });
      });

      document.getElementById("regen").addEventListener("click", rebuild);
      document.getElementById("replay").addEventListener("click", replay);

      // --------------------------------------------------------
      // TREE SYSTEM
      // --------------------------------------------------------
      const TMP_UP = new THREE.Vector3(0, 1, 0);
      let treeGroup = null;
      let segments = [];
      let startClock = 0;
      let totalGrow = 6.0;

      function randRange(a, b) {
        return a + Math.random() * (b - a);
      }

      function rebuild() {
        if (treeGroup) {
          scene.remove(treeGroup);
          treeGroup.traverse((o) => {
            if (o.isMesh) {
              o.geometry && o.geometry.dispose();
              o.material && o.material.dispose();
            }
          });
        }

        const iter = parseInt(iterInput.value, 10);
        const angleDeg = parseFloat(angleInput.value);
        const randomness = parseFloat(randInput.value);
        totalGrow = parseFloat(growInput.value);

        treeGroup = new THREE.Group();
        treeGroup.position.y = 0;
        scene.add(treeGroup);
        segments = [];

        const root = new THREE.Vector3(0, 0, 0);
        const dir = new THREE.Vector3(0, 1, 0);

        // gövde biraz daha kalın ve uzun
        growBranch(
          root,
          dir,
          3.2, // gövde uzunluğu
          0.32, // taban yarıçapı
          iter,
          (angleDeg * Math.PI) / 180,
          randomness
        );

        const per = totalGrow / segments.length;
        segments.forEach((s, i) => {
          s.startTime = i * per * 0.85;
          s.duration = per * 0.9;
        });

        replay();
      }

      function replay() {
        startClock = performance.now() / 1000;
        for (const s of segments) {
          if (s.leaf) {
            s.mesh.scale.setScalar(0.001);
            s.mesh.material.opacity = 0.0;
          } else {
            s.mesh.userData.baseLen = s.mesh.scale.y;
            s.mesh.scale.y = 0.001;
            s.mesh.material.opacity = 1.0;
          }
        }
      }

      // gövde / dal için daha organik silindir
      const barkColors = [0x3b271a, 0x4a3321, 0x5a3f28];

      function addBranchSegment(start, end, radius, depth) {
        const length = start.distanceTo(end);
        const radialSegs = 10;
        const heightSegs = 3;

        const geom = new THREE.CylinderGeometry(
          radius * 0.7, // top radius
          radius, // bottom radius
          1,
          radialSegs,
          heightSegs,
          true
        );
        geom.translate(0, 0.5, 0);

        // hafif “bark” gürültüsü vertex bazlı
        const posAttr = geom.attributes.position;
        const v = new THREE.Vector3();
        for (let i = 0; i < posAttr.count; i++) {
          v.fromBufferAttribute(posAttr, i);
          const noise = (Math.sin(v.y * 8 + i * 1.7) + 1) * 0.5;
          const rN = (noise - 0.5) * 0.12; // 0.12 çok abartı değil
          const radial = new THREE.Vector3(v.x, 0, v.z)
            .normalize()
            .multiplyScalar(rN);
          v.add(radial);
          posAttr.setXYZ(i, v.x, v.y, v.z);
        }
        posAttr.needsUpdate = true;
        geom.computeVertexNormals();

        const color = barkColors[depth % barkColors.length];
        const mat = new THREE.MeshStandardMaterial({
          color,
          roughness: 0.9,
          metalness: 0.05,
          transparent: true,
        });

        const mesh = new THREE.Mesh(geom, mat);

        const diff = end.clone().sub(start);
        const dir = diff.clone().normalize();

        const q = new THREE.Quaternion().setFromUnitVectors(TMP_UP, dir);
        mesh.quaternion.copy(q);
        mesh.position.copy(start);
        mesh.scale.set(1, length, 1);
        mesh.userData.baseLen = length;

        treeGroup.add(mesh);
        return mesh;
      }

      // yaprak taçları: gerçek ağaç gibi "bulut bulut"
      function addLeafCrown(center, radius, density) {
        const count = density;
        for (let i = 0; i < count; i++) {
          const angle = Math.random() * Math.PI * 2;
          const r = radius * Math.sqrt(Math.random());
          const h = randRange(-radius * 0.4, radius * 0.8);

          const x = Math.cos(angle) * r;
          const z = Math.sin(angle) * r;
          const pos = new THREE.Vector3(
            center.x + x,
            center.y + h,
            center.z + z
          );

          const leafGeom = new THREE.SphereGeometry(
            radius * randRange(0.25, 0.45),
            10,
            10
          );
          const leafColor = new THREE.Color(0x295f2b).lerp(
            new THREE.Color(0x3d7f39),
            Math.random()
          );
          const leafMat = new THREE.MeshStandardMaterial({
            color: leafColor,
            roughness: 0.8,
            metalness: 0.05,
            transparent: true,
            opacity: 0.0,
          });

          const leaf = new THREE.Mesh(leafGeom, leafMat);
          leaf.position.copy(pos);
          treeGroup.add(leaf);
          segments.push({ mesh: leaf, leaf: true });
        }
      }

      function growBranch(
        start,
        dir,
        len,
        radius,
        depth,
        angleRad,
        randomness
      ) {
        // hafif yukarı doğru eğimli, kıvrımlı dal
        const end = start.clone().add(dir.clone().multiplyScalar(len));
        const mid = start.clone().lerp(end, 0.55);
        mid.x += randRange(-0.2, 0.2) * depth;
        mid.z += randRange(-0.2, 0.2) * depth;

        const seg1 = addBranchSegment(start, mid, radius, depth);
        const seg2 = addBranchSegment(mid, end, radius * 0.9, depth);
        segments.push({ mesh: seg1, leaf: false });
        segments.push({ mesh: seg2, leaf: false });

        if (depth <= 0) {
          // tepe bölgesinde büyük taç
          const crownRadius = Math.max(0.9, radius * 6);
          const density = 35 + Math.floor(Math.random() * 15);
          addLeafCrown(end, crownRadius, density);
          return;
        }

        const childCount = Math.random() < 0.5 ? 3 : 2;

        for (let i = 0; i < childCount; i++) {
          const yaw = randRange(-Math.PI, Math.PI);
          const downwardBias = 0.08 * (3 - depth); // üst dallar hafif sarkık
          const pitch =
            angleRad +
            randRange(-angleRad * randomness, angleRad * randomness) +
            downwardBias;

          const qYaw = new THREE.Quaternion().setFromAxisAngle(TMP_UP, yaw);
          const right = new THREE.Vector3(1, 0, 0).applyQuaternion(qYaw);
          const qPitch = new THREE.Quaternion().setFromAxisAngle(right, pitch);

          const newDir = dir
            .clone()
            .applyQuaternion(qYaw)
            .applyQuaternion(qPitch)
            .normalize();

          const newLen = len * randRange(0.55, 0.75);
          const newRad = radius * randRange(0.55, 0.7);
          const spawn = start.clone().lerp(end, randRange(0.45, 0.9));

          // çok ince dalları limitli tut
          if (newRad < 0.04) continue;

          growBranch(
            spawn,
            newDir,
            newLen,
            newRad,
            depth - 1,
            angleRad,
            randomness
          );
        }
      }

      // --------------------------------------------------------
      // ANIMATION LOOP
      // --------------------------------------------------------
      function animate() {
        requestAnimationFrame(animate);

        const t = performance.now() / 1000 - startClock;
        for (const s of segments) {
          const p = Math.min(1, (t - (s.startTime || 0)) / (s.duration || 1));
          if (p < 0) continue;

          if (s.leaf) {
            const scale = THREE.MathUtils.lerp(0.001, 1, p);
            s.mesh.scale.setScalar(scale);
            s.mesh.material.opacity = p;
          } else {
            const base = s.mesh.userData.baseLen || 1;
            s.mesh.scale.y = Math.max(0.0001, base * p);
          }
        }

        controls.update();
        renderer.render(scene, camera);
      }

      rebuild();
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
